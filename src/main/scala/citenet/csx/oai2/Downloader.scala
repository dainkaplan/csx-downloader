package citenet.csx.oai2
import java.net.URL
import java.io.File
import StringToURL._
import CloseSourceAfter._
import FileUtils._
import scalax.io.JavaConverters._

class DownloaderConfig {
    var maxLoops: Int = 9999
    var maxDownloadTries: Int = 10
}

object DownloaderApp extends App {
    var rawfiles = new RawFileDownloader(Some("./"))
    rawfiles.maxLoops = 3

    val dler = new DocumentDownloader(rawfiles)
    // Blocks until it's done
    dler.download(doc => {
        println("[%s] -- %s".format(doc.source, doc.title))
    })
}

class DocumentDownloader(dler: BaseDownloader) {
    /**
     * After a page of results has been downloaded, the handler will be called
     * once for each document within that set of results.
     */
    def download(handler: Document => Unit) = {
        dler.download((content) => {
            DocumentDownloader.toDocumentList(content).foreach(doc => {
                handler(doc)
            })
        })
    }
}

object DocumentDownloader {
    def toDocumentList(content: String) = {
        import xml.XML
        val root = XML.loadString(content)
        (root \\ "record").view.map(n => Document.fromXml(n))
    }
}

class RawFileDownloader(outputDir: Option[String] = None) extends Downloader {
    val tmpDirectory = outputDir match {
        case Some(dir) => {
            val f = new File(dir)
            if (f.exists()) f
            else throw new Exception("Specified tmp dir \"%s\" doesn't exist!".format(dir))
        }
        case None => null
    }
    var count = 0

    protected def Noop(src: String) = Unit
    protected def saveAndThen(src: String)(then: (String => Unit)) = {
        createTempFile(src)
        then(src)
    }

    override def download(handler: (String => Unit) = Noop) {
        val (lastToken, lastCount) = if (resumptionToken != None) findLastToken() else (resumptionToken, count)
        count = lastCount
        resumptionToken = lastToken
        super.download((src) => saveAndThen(src)(handler))
    }

    def createTempFile(src: String) = {
        count += 1
        val f = File.createTempFile("oai-", ".tmp-%d".format(count), tmpDirectory)
        writeToFile(f) { p => p.print(src) }
    }

    /**
     * Scans output directory for files generated by this program, and orders them by
     * the last digits of the extension. Then looks through them newest -> oldest,
     * trying to find a resumption token. Returns the first one it finds, along with
     * the number from the file name.
     */
    def findLastToken(): Tuple2[Option[String], Int] = {
        val targetDir = if (tmpDirectory == null) new File(System.getProperty("java.io.tmpdir")) else tmpDirectory
        RawFileDownloader.findLastToken(targetDir.list(), BaseDownloader.findResumptionTokenInFile(targetDir.getAbsolutePath()))
    }
}

object RawFileDownloader {
    object RawFileName {
        val pattern = """^.*\.tmp-(\d+)$""".r
        def unapply(filename: String) = {
            val pattern(num) = filename
            Some(num.toInt)
        }
    }

    def filterFiles(files: Array[String]) = {
        files
            .filter(fname => fname.startsWith("oai-"))
            .sortBy(fname => { val RawFileName(count) = fname; count })
            .reverse
    }

    def findLastFile(files: Array[String]) = {
        val sorted = filterFiles(files)
        if (sorted.size > 0) Some(sorted(0)) else None
    }

    def findLastCount(files: Array[String]) = {
        findLastFile(files) match {
            case Some(file) => val RawFileName(count) = file; count
            case None => 0
        }
    }

    def findLastToken(files: Array[String], getToken: String => Option[String]): Tuple2[Option[String], Int] = {
        val sorted = filterFiles(files)
        var lastToken: Option[String] = None
        val lastCount = findLastCount(sorted)
        sorted.takeWhile(fname => {
            lastToken = getToken(fname)
            lastToken == None
        })
        (lastToken, lastCount)
    }
}

trait Downloader extends BaseDownloader {
    val baseUrl = "http://citeseerx.ist.psu.edu/oai2?verb=ListRecords"
    val initUrl = baseUrl + "&metadataPrefix=oai_dc"
    def resumeUrl(token: String) = baseUrl + "&resumptionToken=%s".format(token)
}

trait BaseDownloader {
    val baseUrl: String
    val initUrl: String
    def resumeUrl(token: String): String
    var maxLoops: Int = 9999
    var maxDownloadTries = 10
    var resumptionToken: Option[String] = None

    def download(handler: String => Unit): Unit = {
        for (i <- 1 to maxLoops) {
            var data: Option[String] = None
            val url = resumptionToken match {
                case Some(t) => resumeUrl(t)
                case None => initUrl
            }
            (1 to maxDownloadTries).takeWhile(cnt => {
                println("%d [%d]: %s".format(i, cnt, url))
                data = fetch(url)
                data == None // Try again?
            })

            data match {
                case Some(str) => {
                    resumptionToken = BaseDownloader.findResumptionToken(str)
                    handler(str)
                    if (resumptionToken == None) return // we're done
                }
                case None => return // either we errored out too many times, or we're done
            }
        }
    }

    def fetch(url: String): Option[String] = {
        try {
            if (url.startsWith("http"))
                Some(new URL(url).asInput.slurpString(io.Codec.UTF8))
            else
                Some(new File(url).asInput.slurpString(io.Codec.UTF8))
        } catch {
            case _ => None
        }
    }

    // ============================================================
    // ======================== FOR JAVA ==========================
    trait DownloadCallback {
        def handleDownload(src: String)
    }

    def download(handler: DownloadCallback) {
        download(handler.handleDownload _)
    }
    // ======================== FOR JAVA ==========================
    // ============================================================
}

object BaseDownloader {
    /**
     * Searches for a resumption token within a file specified by filename.
     */
    def findResumptionTokenInFile(path: String)(filename: String): Option[String] = {
        val str = new File(path + "/" + filename).asInput.slurpString(io.Codec.UTF8)
        val token = findResumptionToken(str)
        token
    }

    def findResumptionToken(str: String): Option[String] = {
        var token: Option[String] = None
        val regex = """^<resumptionToken>([^<]+)</resumptionToken>.*""".r
        val lines = str.split("\n")
        lines.reverse.takeWhile(line => {
            line.trim() match {
                case regex(t) => token = Some(t); false
                case _ => true // keep searching
            }
        })
        println("Found token:" + token)
        token
    }
}