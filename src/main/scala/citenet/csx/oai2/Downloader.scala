package citenet.csx.oai2
import java.net.URL
import java.io.File
import StringToURL._
import CloseSourceAfter._
import FileUtils._

class DownloaderConfig {
    var maxLoops: Int = 9999
    var maxDownloadTries: Int = 10
}

object DownloaderApp extends App {

    var dler = new RawFileDownloader(Some("./"), maxLoops = 3)
    dler.download()
}

class RawFileDownloader(outputDir: Option[String] = None, maxLoops: Int) {
    val tmpDirectory = outputDir match {
        case Some(dir) => {
            val f = new File(dir)
            if (f.exists()) f
            else throw new Exception("specified tmp dir \"%s\" doesn't exist!".format(dir))
        }
        case None => null
    }
    var count = 0
    val dler = new Downloader(maxLoops)

    def download(initialResumptionToken: Option[String] = None, initialCount: Int = 0, handler: (io.Source => Unit) = { _ => Unit }) {
        val (lastToken, lastCount) = if (initialResumptionToken != None) findLastToken() else (initialResumptionToken, initialCount)
        count = lastCount
        dler.download(lastToken, handler = (src) => { createTempFile(src); handler(src) })
    }

    def createTempFile(src: io.Source) = {
        count += 1
        val f = File.createTempFile("oai-", ".tmp-%d".format(count), tmpDirectory)
        writeToFile(f) { p => src.getLines().foreach(l => { p.println(l); println(l) }) }
    }

    /**
     * Scans output directory for files generated by this program, and orders them by
     * the last digits of the extension. Then looks through them newest -> oldest,
     * trying to find a resumption token. Returns the first one it finds, along with
     * the number from the file name.
     */
    def findLastToken(): Tuple2[Option[String], Int] = {
        val targetDir = if (tmpDirectory == null) new File(System.getProperty("java.io.tmpdir")) else tmpDirectory
        RawFileDownloader.findLastToken(targetDir.list(), Downloader.findResumptionToken(targetDir.getAbsolutePath()))
    }
}

object RawFileDownloader {
    object RawFileName {
        val pattern = """^.*\.tmp-(\d+)$""".r
        def unapply(filename: String) = {
            val pattern(num) = filename
            Some(num.toInt)
        }
    }

    def filterFiles(files:Array[String]) = {
    	files
    		.filter(fname => fname.startsWith("oai-"))
        	.sortBy(fname => { val RawFileName(count) = fname; count })
        	.reverse
    }
    
    def findLastFile(files: Array[String]) = {
        val sorted = filterFiles(files)
        if (sorted.size > 0)  Some(sorted(0)) else None
    }
    
    def findLastCount(files:Array[String]) = {
        findLastFile(files) match {
            case Some(file) => val RawFileName(count) = file; count
            case None => 0
        }
    }
    
    def findLastToken(files: Array[String], getToken: String => Option[String]): Tuple2[Option[String], Int] = {
        val sorted = filterFiles(files)
        var lastToken: Option[String] = None
        val lastCount = findLastCount(sorted)
        sorted.takeWhile(fname => {
            lastToken = getToken(fname)
            lastToken == None
        })
        (lastToken, lastCount)
    }
}

class Downloader(maxLoops: Int = 9999) {

    val maxDownloadTries = 10
    val baseUrl = "http://citeseerx.ist.psu.edu/oai2?verb=ListRecords"
    val initUrl = baseUrl + "&metadataPrefix=oai_dc"
    def resumeUrl(token: String) = baseUrl + "&resumptionToken=%s".format(token)

    def download(initialResumptionToken: Option[String] = None, handler: io.Source => Unit): Unit = {
        var token = initialResumptionToken
        for (i <- 1 to maxLoops) {
            var src: Option[io.Source] = None
            val url = token match {
                case Some(t) => resumeUrl(t)
                case None => initUrl
            }
            (1 to maxDownloadTries).takeWhile(cnt => {
                println("%d [%d]: %s".format(i, cnt, url))
                src = dataFromUrl(url)
                src == None // Try again?
            })
            src match {
                case Some(source) => {
                    source.closeAfter {
                        token = Downloader.findResumptionToken(source)
                        handler(source)
                        if (token == None) return // we're done
                    }
                }
                case None => return // either we errored out too many times, or we're done
            }
        }
    }

    /**
     * Note: returned source must be closed!!
     */
    def dataFromUrl(url: URL): Option[io.Source] = {
        try {
            Some(io.Source.fromURL(url)(scala.io.Codec.UTF8))
        } catch {
            case _ => None
        }
    }
}

object Downloader {
    /**
     * Searches for a resumption token within a file specified by filename.
     */
    def findResumptionToken(path: String)(filename: String): Option[String] = {
        val src = io.Source.fromFile(path + "/" + filename)
        val token = findResumptionToken(src)
        src.close()
        token
    }

    def findResumptionToken(src: io.Source): Option[String] = {
        findResumptionToken(src.getLines.toSeq)
    }
    
    def findResumptionToken(src: Seq[String]): Option[String] = {
        var token: Option[String] = None
        val regex = """^<resumptionToken>([^<]+)</resumptionToken>.*""".r
        src.takeWhile(line => {
            line.trim() match {
                case regex(t) => token = Some(t); false
                case _ => true // keep searching
            }
        })
        token
    }
}