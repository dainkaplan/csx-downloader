package citenet.csx.oai2
import java.net.URL
import java.io.File
import StringToURL._
import CloseSourceAfter._
import FileUtils._

object DownloaderApp extends App {

    var dler = new RawFileDownloader(Some("./"))
    dler.download()
}

class RawFileDownloader(outputDir: Option[String] = None) {
    val tmpDirectory = outputDir match {
        case Some(dir) => {
            val f = new File(dir)
            if (f.exists()) f
            else throw new Exception("specified tmp dir \"%s\" doesn't exist!".format(dir))
        }
        case None => null
    }
    var count = 0
    val dler = new Downloader(handler = createTempFile, maxLoops = 3)

    def download() {
        val (lastToken, lastCount) = findLastToken()
        count = lastCount
        dler.download(lastToken)
    }

    def createTempFile(src: io.Source) = {
        count += 1
        val f = File.createTempFile("oai-", ".tmp-%d".format(count), tmpDirectory)
        writeToFile(f) { p => src.getLines().foreach(l => { p.println(l); println(l) }) }
    }

    /**
     * Scans output directory for files generated by this program, and orders them by
     * the last digits of the extension. Then looks through them newest -> oldest,
     * trying to find a resumption token. Returns the first one it finds, along with
     * the number from the file name.
     */
    def findLastToken(): Tuple2[Option[String], Int] = {
        val targetDir = if (tmpDirectory == null) new File(System.getProperty("java.io.tmpdir")) else tmpDirectory
        RawFileDownloader.findLastToken(targetDir.list(), Downloader.findResumptionToken(targetDir.getAbsolutePath()))
    }
}

object RawFileDownloader {
    def findLastToken(files:Array[String], getToken:String=>Option[String]): Tuple2[Option[String], Int] = {    
        val ls = files.filter(fname => fname.startsWith("oai-"))
        val p = """^.*\.tmp-(\d+)$""".r
        val sorted = ls.sortBy(fname => { val p(a) = fname; a.toInt}).reverse
        var lastToken: Option[String] = None
        var lastCount = 0
        sorted.takeWhile(fname => {
            lastToken = getToken(fname)
            lastToken match {
                case Some(t) => { lastCount = p.findFirstMatchIn(fname).get.group(1).toInt; false }
                case None => true
            }
        })
        (lastToken, lastCount)
    }
}

class Downloader(maxLoops: Int = 9999, handler: io.Source => Unit) {

    val maxDownloadTries = 10
    val baseUrl = "http://citeseerx.ist.psu.edu/oai2?verb=ListRecords"
    val initUrl = baseUrl + "&metadataPrefix=oai_dc"
    def resumeUrl(token: String) = baseUrl + "&resumptionToken=%s".format(token)

    def download(initialResumptionToken: Option[String] = None): Unit = {
        var token = initialResumptionToken
        for (i <- 1 to maxLoops) {
            var src: Option[io.Source] = None
            val url = token match {
                case Some(t) => resumeUrl(t)
                case None => initUrl
            }
            1.to(maxDownloadTries).takeWhile(cnt => {
                println("%d [%d]: %s".format(i, cnt, url))
                src = dataFromUrl(url)
                src == None // Try again?
            })
            src match {
                case Some(source) => {
                    source.closeAfter {
                        token = Downloader.findResumptionToken(source)
                        handler(source)
                        if (token == None) return // we're done
                    }
                }
                case None => return // either we errored out too many times, or we're done
            }
        }
    }

    /**
     * Note: returned source must be closed!!
     */
    def dataFromUrl(url: URL): Option[io.Source] = {
        try {
            Some(io.Source.fromURL(url)(scala.io.Codec.UTF8))
        } catch {
            case _ => None
        }
    }
}

object Downloader {
    /**
     * Searches for a resumption token within a file specified by filename.
     */
    def findResumptionToken(path:String)(filename: String): Option[String] = {
        val src = io.Source.fromFile(path + "/" + filename)
        val token = findResumptionToken(src)
        src.close()
        token
    }

    def findResumptionToken(src: io.Source): Option[String] = {
        findResumptionToken(src.getLines.toSeq)
    }
    
    def findResumptionToken(src: Seq[String]): Option[String] = {
        var token: Option[String] = None
        val regex = """^<resumptionToken>([^<]+)</resumptionToken>.*""".r
        src.takeWhile(line => {
            line.trim() match {
                case regex(t) => token = Some(t); false
                case _ => true // keep searching
            }
        })
        token
    }
}